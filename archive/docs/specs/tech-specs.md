# Technical Specifications

## 1. System Overview

**Architecture**: Progressive Web App (PWA) with Next.js
**Primary Stack**: Next.js 15.1 + React 19.1 + TypeScript 5.9 + Tailwind 4.1 + Tiptap 3.4
**Deployment**: Vercel (recommended) or Firebase Hosting
**Core Concept**: Three-mode workflow (Create, Edit, Study) separating fast capture, confident revision, and AI-powered key term identification

### Quality Assurance Philosophy

**Contract-First, Test-After Approach** - We prioritize shipping fast while maintaining quality through:

1. **Zod Schema Contracts** as the primary quality gate
   - Define data contracts before implementation
   - Runtime validation at all API boundaries
   - Type safety through TypeScript inference
   - Self-documenting code

2. **Pragmatic Testing** (test after implementation)
   - Focus on high-value integration tests
   - E2E smoke tests for critical paths
   - Selective unit tests for complex logic only
   - No TDD - tests validate behavior, not drive design

3. **Risk Mitigation Strategy**
   - 100% API contract coverage (Zod)
   - 70-80% integration test coverage of critical paths
   - 5-10 E2E user journeys
   - 30-50% unit test coverage (pragmatic, not arbitrary)

This approach prioritizes **MVP velocity** while maintaining **production-grade quality** through contracts and strategic testing.

## 2. Frontend Architecture

### Core Framework

- **Next.js**: 15.1.0 with App Router
  - Server Components for initial page loads
  - Client Components for interactive features
  - API Routes for serverless backend functions
  - Middleware for authentication
  - Image optimization with next/image
- **React**: 19.1.1 with concurrent features
- **TypeScript**: 5.9.3 with strict mode enabled
- **Build Tool**: Next.js built-in (Turbopack in dev, Webpack in production)

### UI Layer

**Component Library**

- Shadcn UI components built on Radix UI primitives
- Components in `/components/ui` (auto-generated by Shadcn CLI)
- Custom app components in `/components`
- Server Components by default, Client Components marked with 'use client'

**Styling**

- Tailwind CSS 4.1.13 with PostCSS
- Shadcn UI theming via CSS variables
- Responsive design with mobile-first approach
- Dark mode support via next-themes with CSS variables
- Global styles in `app/globals.css`

**Icons**

- Lucide React (544+ icons) - included with Shadcn UI

### Rich Text Editor

**Tiptap 3.4.2** (Client-side only)

- Core editor framework
- Starter Kit: basic formatting, headings, lists, code blocks
- Placeholder extension for empty state hints
- Custom extensions for:
  - Nursing terminology autocomplete (GPT-4.1 nano)
  - Inline diff highlighting (Edit Mode)
- Must use 'use client' directive

### State Management

**Zustand 5.0.8** (Client-side state)

- Lightweight store for:
  - Editor mode (Create, Edit, Study)
  - Mode transition state
  - User preferences
  - Note metadata
  - AI request quota tracking
- Immer 10.1.3 for immutable state updates
- Persist middleware for localStorage sync

**React Server Components**

- Server-side data fetching for initial loads
- Client-side updates via Zustand
- Optimistic UI updates with React.useOptimistic

### Local Database

**Dexie 4.2.0** (IndexedDB wrapper - Client-side only)

- Offline-first note storage
- Schema versioning and migrations
- Full-text search indexing
- Sync queue for Firebase replication
- Must use 'use client' directive

### PWA Configuration

**next-pwa 5.6.0**

- Service Worker generation
- Offline support with workbox
- App manifest configuration
- Install prompt handling
- Background sync for queue processing

**PWA Features**

- Installable on desktop and mobile
- Offline-first architecture
- Push notifications (future)
- Background sync for note updates

## 3. Backend Architecture (Next.js + Firebase Hybrid)

### Next.js API Routes

**Route Handlers** (`app/api/**/route.ts`)

- RESTful endpoints using App Router conventions
- Serverless functions deployed to Vercel/Firebase
- Middleware for authentication validation
- CORS handling in middleware.ts

**API Endpoints**

```
POST /api/auth/initialize       # Create user doc after signup
POST /api/ai/autocomplete        # GPT-4.1 nano autocomplete
POST /api/ai/spot-terms          # GPT-4o-mini key term spotting
GET  /api/users/quota            # Check usage quota
POST /api/users/update-tier      # Update subscription
```

### Firebase Services

**Authentication** (Client SDK + Admin SDK)

- Client: firebase/auth for frontend auth
- Server: firebase-admin for token verification in API routes
- Email/password signup
- Session management with cookies (httpOnly, secure)

**Firestore Database**

- Client SDK: Direct access for real-time updates
- Admin SDK: Server-side operations in API routes
- Collections: `users`, `notes`, `versionSnapshots` (backend only)
- Security rules for user isolation
- Real-time listeners in Client Components
- Offline support with local cache

**Cloud Functions** (Optional - can use Next.js API routes instead)

- Only for heavy background tasks
- Scheduled functions (quota reset, snapshot cleanup)
- Database triggers (cascade deletes)

**Storage**

- Note attachments (future)
- Exported note files (future)

### API Integration

**OpenAI API** (5.23.1) via Next.js API Routes

- Server-side calls from `/app/api/ai/*` routes
- **GPT-4.1 nano** for autocompletion (<100ms target)
- **GPT-4o-mini with Structured Outputs** for key term spotting (<5s target)
- Fallback: Local nursing terms dictionary when quota exceeded
- Environment variables stored in `.env.local`

## 4. Project Structure

```
nexly-rn/
├── app/
│   ├── (auth)/
│   │   ├── login/
│   │   │   └── page.tsx          # Login page
│   │   ├── signup/
│   │   │   └── page.tsx          # Signup page
│   │   └── layout.tsx            # Auth layout
│   ├── (dashboard)/
│   │   ├── notes/
│   │   │   ├── [id]/
│   │   │   │   └── page.tsx      # Note editor page
│   │   │   └── page.tsx          # Notes library
│   │   ├── onboarding/
│   │   │   └── page.tsx          # 2-screen onboarding
│   │   └── layout.tsx            # Dashboard layout
│   ├── api/
│   │   ├── auth/
│   │   │   └── initialize/
│   │   │       └── route.ts      # User initialization
│   │   ├── ai/
│   │   │   ├── autocomplete/
│   │   │   │   └── route.ts      # Autocomplete endpoint
│   │   │   └── spot-terms/
│   │   │       └── route.ts      # Key term spotting
│   │   └── users/
│   │       ├── quota/
│   │       │   └── route.ts      # Get quota
│   │       └── update-tier/
│   │           └── route.ts      # Update subscription
│   ├── layout.tsx                # Root layout
│   ├── page.tsx                  # Landing page
│   └── globals.css               # Global styles
├── components/
│   ├── ui/                       # Shadcn components
│   │   ├── button.tsx
│   │   ├── dialog.tsx
│   │   ├── alert-dialog.tsx
│   │   ├── toast.tsx
│   │   └── ...
│   ├── editor/
│   │   ├── tiptap-editor.tsx     # Main editor (Client)
│   │   ├── autocomplete-popup.tsx
│   │   ├── inline-diff.tsx       # Edit mode diff
│   │   └── toolbar.tsx
│   ├── notes/
│   │   ├── note-list.tsx
│   │   ├── note-card.tsx
│   │   └── edit-study-dialog.tsx
│   ├── study/
│   │   └── key-terms-sidebar.tsx # Study mode sidebar
│   └── mode-selector.tsx         # Mode toggle
├── lib/
│   ├── firebase/
│   │   ├── client.ts             # Client SDK setup
│   │   ├── admin.ts              # Admin SDK setup (server)
│   │   └── firestore.ts          # Firestore helpers
│   ├── dexie/
│   │   ├── db.ts                 # Dexie schema
│   │   └── sync.ts               # Sync logic
│   ├── ai/
│   │   ├── autocomplete.ts       # Autocomplete logic
│   │   └── key-terms.ts          # Key term spotting
│   ├── diff.ts                   # Diff calculation
│   ├── utils.ts                  # Utility functions
│   └── validations.ts            # Zod schemas
├── store/
│   ├── editor-store.ts           # Editor state (Zustand)
│   ├── user-store.ts             # User preferences
│   └── notes-store.ts            # Notes cache
├── hooks/
│   ├── use-firebase-auth.ts      # Auth hook
│   ├── use-note-sync.ts          # Sync hook
│   ├── use-autocomplete.ts       # Autocomplete hook
│   └── use-quota.ts              # Quota tracking
├── public/
│   ├── manifest.json             # PWA manifest
│   ├── icons/                    # App icons
│   └── dictionaries/
│       └── nursing-terms.json    # Fallback dictionary
├── middleware.ts                 # Auth & CORS middleware
├── next.config.js                # Next.js config with PWA
└── tailwind.config.ts            # Tailwind + Shadcn theme
```

## 5. Data Architecture

### Schema Design

**Notes Table** (Firestore/Dexie)

```typescript
interface Note {
  id: string; // UUID
  userId: string;
  title: string;
  content: JSONContent; // Tiptap JSON type
  mode: "create" | "edit" | "study";
  createdAt: Timestamp;
  updatedAt: Timestamp;
  tags: string[];
  metadata: {
    courseCode?: string;
  };
}
```

**Version Snapshots Collection** (Firestore/Dexie - Backend Only, No UI in MVP)

```typescript
interface VersionSnapshot {
  id: string;
  noteId: string;
  userId: string;
  content: JSONContent;
  mode: "create" | "edit" | "study";
  timestamp: Timestamp;
  changesSummary: {
    addedWords: number;
    removedWords: number;
    wordCountChange: number;
  };
  snapshotType: "auto" | "manual" | "mode_switch";
}
```

**User Preferences** (Firestore)

```typescript
interface UserProfile {
  userId: string;
  email: string;
  displayName: string;
  tier: "free" | "pro" | "team";
  usage: {
    autocompleteRequests: number;
    keyTermSpottingUses: number;
    resetDate: Timestamp;
  };
  settings: {
    theme: "light" | "dark" | "system";
    autoSave: boolean;
  };
  createdAt: Timestamp;
  updatedAt: Timestamp;
}
```

### Validation Layer (Contract-First Development)

**Zod 3.25.67** - Primary Quality Assurance Mechanism

Zod schemas serve as the **single source of truth** for data contracts, replacing traditional TDD as the primary quality and risk mitigation strategy:

- **API Contract Validation**: All API inputs/outputs validated at runtime
- **Type Safety**: Automatic TypeScript type inference from schemas
- **Form Validation**: Type-safe validation with react-hook-form integration
- **Environment Validation**: Strict validation of environment variables
- **Shared Contracts**: Single schema definition used across client and server
- **Error Boundaries**: Graceful error handling with clear validation messages

**Schema Organization**:
```typescript
// lib/validations.ts - Central contract definitions
export const NoteSchema = z.object({
  id: z.string().uuid(),
  userId: z.string(),
  title: z.string().min(1).max(200),
  content: z.any(), // Tiptap JSONContent
  mode: z.enum(["create", "edit", "study"]),
  createdAt: z.date(),
  updatedAt: z.date(),
  tags: z.array(z.string()),
  metadata: z.object({
    courseCode: z.string().optional(),
  }),
});

// API contract for autocomplete
export const AutocompleteRequestSchema = z.object({
  text: z.string().max(500),
  context: z.string().max(2000),
});

export const AutocompleteResponseSchema = z.object({
  suggestions: z.array(z.string()),
  confidence: z.number().min(0).max(1),
});
```

**Contract Enforcement Pattern**:
```typescript
// app/api/ai/autocomplete/route.ts
export async function POST(request: NextRequest) {
  // Parse and validate request against contract
  const body = await request.json();
  const validated = AutocompleteRequestSchema.safeParse(body);

  if (!validated.success) {
    return NextResponse.json(
      { error: "Invalid request", details: validated.error },
      { status: 400 }
    );
  }

  // Business logic with type-safe data
  const result = await processAutocomplete(validated.data);

  // Validate response against contract before sending
  return NextResponse.json(AutocompleteResponseSchema.parse(result));
}
```

This contract-first approach ensures:
- API consumers and producers agree on data shape
- Runtime validation catches integration issues early
- Type safety eliminates entire classes of bugs
- Clear error messages for debugging
- Self-documenting code through schemas

## 6. Authentication Flow

### Client-Side Auth (Firebase Client SDK)

```typescript
// hooks/use-firebase-auth.ts
"use client";

import { auth } from "@/lib/firebase/client";
import {
  signInWithEmailAndPassword,
  createUserWithEmailAndPassword,
  signOut,
} from "firebase/auth";

export function useFirebaseAuth() {
  // Auth state management
  // Return user, loading, error states
}
```

### Server-Side Auth (Firebase Admin SDK)

```typescript
// middleware.ts
import { NextResponse } from "next/server";
import type { NextRequest } from "next/server";
import { adminAuth } from "@/lib/firebase/admin";

export async function middleware(request: NextRequest) {
  const token = request.cookies.get("auth-token")?.value;

  if (!token) {
    return NextResponse.redirect(new URL("/login", request.url));
  }

  try {
    const decodedToken = await adminAuth.verifyIdToken(token);
    // Add user to request headers
    const requestHeaders = new Headers(request.headers);
    requestHeaders.set("x-user-id", decodedToken.uid);

    return NextResponse.next({
      request: {
        headers: requestHeaders,
      },
    });
  } catch (error) {
    return NextResponse.redirect(new URL("/login", request.url));
  }
}

export const config = {
  matcher: ["/notes/:path*", "/api/ai/:path*"],
};
```

### API Route Protection

```typescript
// app/api/ai/autocomplete/route.ts
import { NextRequest, NextResponse } from "next/server";
import { adminAuth } from "@/lib/firebase/admin";

export async function POST(request: NextRequest) {
  const token = request.headers.get("authorization")?.split("Bearer ")[1];

  if (!token) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  try {
    const decodedToken = await adminAuth.verifyIdToken(token);
    const userId = decodedToken.uid;

    // Process request with userId
  } catch (error) {
    return NextResponse.json({ error: "Invalid token" }, { status: 401 });
  }
}
```

## 7. Real-time Data Flow

### Server Components for Initial Load

```typescript
// app/(dashboard)/notes/page.tsx
import { adminDb } from "@/lib/firebase/admin";
import { NotesList } from "@/components/notes/note-list";

export default async function NotesPage() {
  // Fetch initial data server-side
  const notes = await adminDb
    .collection("users")
    .doc(userId)
    .collection("notes")
    .orderBy("updatedAt", "desc")
    .limit(20)
    .get();

  return <NotesList initialNotes={notes.docs.map((d) => d.data())} />;
}
```

### Client Components for Real-time Updates

```typescript
// components/notes/note-list.tsx
'use client';

import { useEffect, useState } from 'react';
import { db } from '@/lib/firebase/client';
import { collection, query, orderBy, onSnapshot } from 'firebase/firestore';

export function NotesList({ initialNotes }) {
  const [notes, setNotes] = useState(initialNotes);

  useEffect(() => {
    const q = query(
      collection(db, `users/${userId}/notes`),
      orderBy('updatedAt', 'desc')
    );

    const unsubscribe = onSnapshot(q, (snapshot) => {
      const updatedNotes = snapshot.docs.map(doc => doc.data());
      setNotes(updatedNotes);
    });

    return () => unsubscribe();
  }, [userId]);

  return (
    // Render notes
  );
}
```

## 8. Performance Optimization

### Next.js Optimizations

**Code Splitting**

- Automatic route-based code splitting
- Dynamic imports for heavy components
- Lazy load Tiptap editor bundle

```typescript
// Lazy load editor
const TiptapEditor = dynamic(
  () => import("@/components/editor/tiptap-editor"),
  {
    ssr: false,
    loading: () => <EditorSkeleton />,
  }
);
```

**Image Optimization**

- Use next/image for all images
- Automatic format selection (WebP, AVIF)
- Lazy loading by default

**Font Optimization**

- next/font for optimized font loading
- Preload critical fonts

```typescript
// app/layout.tsx
import { Inter } from "next/font/google";

const inter = Inter({
  subsets: ["latin"],
  display: "swap",
  variable: "--font-inter",
});
```

### Caching Strategy

**Server-Side Caching**

- Revalidate API responses with time-based ISR
- Cache Firestore queries in memory (5-minute TTL)

**Client-Side Caching**

- Dexie for offline notes cache
- React Query for API response caching (future)
- Service Worker cache for static assets

### Bundle Optimization

**Webpack Configuration**

```javascript
// next.config.js
const withPWA = require("next-pwa")({
  dest: "public",
  disable: process.env.NODE_ENV === "development",
  register: true,
  skipWaiting: true,
});

module.exports = withPWA({
  reactStrictMode: true,
  swcMinify: true,
  compiler: {
    removeConsole: process.env.NODE_ENV === "production",
  },
  webpack: (config, { isServer }) => {
    if (!isServer) {
      config.resolve.fallback = {
        ...config.resolve.fallback,
        fs: false,
        net: false,
        tls: false,
      };
    }
    return config;
  },
});
```

## 9. PWA Configuration

### Manifest

```json
// public/manifest.json
{
  "name": "NEXLY RN",
  "short_name": "NEXLY",
  "description": "AI-Powered Nursing Education Platform",
  "start_url": "/notes",
  "display": "standalone",
  "background_color": "#ffffff",
  "theme_color": "#3B82F6",
  "orientation": "portrait-primary",
  "icons": [
    {
      "src": "/icons/icon-72x72.png",
      "sizes": "72x72",
      "type": "image/png",
      "purpose": "any maskable"
    },
    {
      "src": "/icons/icon-192x192.png",
      "sizes": "192x192",
      "type": "image/png",
      "purpose": "any maskable"
    },
    {
      "src": "/icons/icon-512x512.png",
      "sizes": "512x512",
      "type": "image/png",
      "purpose": "any maskable"
    }
  ]
}
```

### Service Worker Strategy

**next-pwa Configuration**

- NetworkFirst for API calls
- CacheFirst for static assets
- StaleWhileRevalidate for pages

```javascript
// Custom service worker (public/sw.js if needed)
self.addEventListener("sync", (event) => {
  if (event.tag === "sync-notes") {
    event.waitUntil(syncNotes());
  }
});

async function syncNotes() {
  // Process Dexie sync queue
}
```

## 10. Pragmatic Testing Strategy (Test After Implementation)

**Philosophy**: Write tests **after** implementing features to validate behavior and mitigate risk, not to drive design. Focus on **high-value integration tests** and **contract validation** rather than exhaustive unit test coverage.

### Quality Assurance Hierarchy

1. **Zod Schema Contracts** (Primary Quality Gate)
   - Define data contracts before implementation
   - Runtime validation at API boundaries
   - Type safety through TypeScript inference
   - **Coverage**: 100% of API endpoints and data models

2. **Integration Testing** (High Priority)
   - Test feature workflows end-to-end
   - Validate API contracts and business logic
   - Test database operations and sync logic
   - **Coverage**: All critical user paths

3. **E2E Testing** (Medium Priority)
   - Smoke tests for core workflows
   - Authentication and authorization flows
   - Mode switching and editor functionality
   - **Coverage**: Happy paths only in MVP

4. **Unit Testing** (Low Priority - Selective)
   - Only for complex utility functions
   - Edge cases in parsing/formatting logic
   - No tests for simple getters/setters
   - **Coverage**: 30-50% (pragmatic, not arbitrary)

### Testing Configuration

**Vitest for Integration Tests**

```typescript
// vitest.config.ts
import { defineConfig } from "vitest/config";
import react from "@vitejs/plugin-react";
import path from "path";

export default defineConfig({
  plugins: [react()],
  test: {
    environment: "jsdom",
    setupFiles: ["./tests/setup.ts"],
    globals: true,
    // No strict coverage thresholds - focus on critical paths
    coverage: {
      provider: "v8",
      reporter: ["text", "json", "html"],
      exclude: [
        "node_modules/",
        "tests/",
        "**/*.d.ts",
        "**/*.config.*",
        "**/mockData",
        "components/ui/**", // Shadcn components (already tested)
      ],
    },
  },
  resolve: {
    alias: {
      "@": path.resolve(__dirname, "./"),
    },
  },
});
```

### Test Examples

**1. API Contract Tests** (Highest Priority)

```typescript
// tests/api/ai/autocomplete.test.ts
import { describe, test, expect } from "vitest";
import { POST } from "@/app/api/ai/autocomplete/route";
import { AutocompleteRequestSchema, AutocompleteResponseSchema } from "@/lib/validations";

describe("Autocomplete API Contract", () => {
  test("accepts valid request and returns valid response", async () => {
    const validRequest = {
      text: "The patient presents with",
      context: "Nursing assessment notes...",
    };

    // Validate request against contract
    const parsedRequest = AutocompleteRequestSchema.parse(validRequest);
    expect(parsedRequest).toBeDefined();

    // Call API
    const request = new Request("http://localhost/api/ai/autocomplete", {
      method: "POST",
      body: JSON.stringify(validRequest),
    });
    const response = await POST(request);
    const data = await response.json();

    // Validate response against contract
    const parsedResponse = AutocompleteResponseSchema.parse(data);
    expect(parsedResponse.suggestions).toBeInstanceOf(Array);
    expect(parsedResponse.confidence).toBeGreaterThanOrEqual(0);
  });

  test("rejects invalid request", async () => {
    const invalidRequest = {
      text: "x".repeat(600), // Exceeds max length
    };

    expect(() => AutocompleteRequestSchema.parse(invalidRequest)).toThrow();
  });
});
```

**2. Integration Tests** (High Priority)

```typescript
// tests/integration/note-sync.test.ts
import { describe, test, expect, beforeEach } from "vitest";
import { db } from "@/lib/dexie/db";
import { syncNoteToFirestore } from "@/lib/dexie/sync";
import "fake-indexeddb/auto";

describe("Note Sync Integration", () => {
  beforeEach(async () => {
    await db.notes.clear();
  });

  test("syncs local note to Firestore", async () => {
    const note = {
      id: "test-123",
      userId: "user-1",
      title: "Test Note",
      content: { type: "doc", content: [] },
      mode: "create" as const,
      createdAt: new Date(),
      updatedAt: new Date(),
      tags: [],
      metadata: {},
    };

    // Add to local DB
    await db.notes.add(note);

    // Sync to Firestore
    const result = await syncNoteToFirestore(note.id);

    expect(result.success).toBe(true);
  });
});
```

**3. Selective Unit Tests** (Low Priority)

```typescript
// tests/utils/diff.test.ts
import { describe, test, expect } from "vitest";
import { calculateDiff } from "@/lib/diff";

describe("Diff Calculation (Complex Logic)", () => {
  test("identifies added words", () => {
    const original = "The patient";
    const updated = "The patient presents with symptoms";

    const diff = calculateDiff(original, updated);

    expect(diff.addedWords).toBe(3);
    expect(diff.removedWords).toBe(0);
  });

  test("handles empty strings", () => {
    const diff = calculateDiff("", "");

    expect(diff.addedWords).toBe(0);
    expect(diff.wordCountChange).toBe(0);
  });
});
```

### E2E Testing with Playwright (Smoke Tests Only)

**Playwright 1.55.0** - Focus on critical user journeys

```typescript
// tests/e2e/auth-flow.spec.ts
import { test, expect } from "@playwright/test";

test("user can sign up and create a note", async ({ page }) => {
  // Signup
  await page.goto("http://localhost:3000/signup");
  await page.fill('input[name="email"]', "test@example.com");
  await page.fill('input[name="password"]', "SecurePass123!");
  await page.click('button[type="submit"]');

  // Create note
  await expect(page).toHaveURL(/.*\/notes/);
  await page.click('button:has-text("New Note")');
  await page.fill('[data-testid="note-title"]', "My First Note");

  // Verify note created
  await expect(page.locator('text="My First Note"')).toBeVisible();
});
```

### Testing Workflow

**Development Process**:
1. **Define contracts first** (Zod schemas)
2. **Implement feature** with type safety
3. **Verify contracts** with integration tests
4. **Add selective tests** for complex logic
5. **Run E2E smoke tests** before deployment

**Pre-commit Checks** (Pragmatic - No Test Failures Block Commits):
```bash
# .husky/pre-commit
npm run lint               # Code style
npm run type-check         # TypeScript errors
# Tests run in CI/CD, not pre-commit (too slow for MVP velocity)
```

**CI/CD Pipeline**:
```bash
npm run lint
npm run type-check
npm run test              # Integration tests
npm run test:e2e          # E2E smoke tests
npm run build             # Verify build succeeds
```

### Risk Mitigation Strategy

| Risk Area | Mitigation Approach | Testing Level |
|-----------|---------------------|---------------|
| API contract breakage | Zod schema validation | 100% coverage |
| Data corruption | Schema validation + DB constraints | Integration tests |
| Auth vulnerabilities | Middleware + token validation | Integration + E2E |
| Sync conflicts | Queue system + retry logic | Integration tests |
| UI regressions | E2E smoke tests | Happy paths only |
| Edge cases | Selective unit tests | As needed |

**Coverage Goals** (Pragmatic):
- API contracts: 100% (enforced by Zod)
- Integration tests: 70-80% of critical paths
- E2E tests: 5-10 key user journeys
- Unit tests: 30-50% (complex logic only)

This approach prioritizes **shipping fast** while maintaining **acceptable quality** for MVP.

## 11. Deployment

### Vercel (Recommended)

**Configuration**

```json
// vercel.json
{
  "buildCommand": "npm run build",
  "devCommand": "npm run dev",
  "installCommand": "npm install",
  "framework": "nextjs",
  "regions": ["iad1"],
  "env": {
    "NEXT_PUBLIC_FIREBASE_API_KEY": "@firebase-api-key",
    "OPENAI_API_KEY": "@openai-api-key"
  }
}
```

**Environment Variables**

- NEXT*PUBLIC*\* for client-side vars
- Server-only vars without NEXT*PUBLIC* prefix
- Store in Vercel dashboard or .env.local

### Firebase Hosting (Alternative)

```json
// firebase.json
{
  "hosting": {
    "public": "out",
    "ignore": ["firebase.json", "**/.*", "**/node_modules/**"],
    "rewrites": [
      {
        "source": "**",
        "destination": "/index.html"
      }
    ],
    "headers": [
      {
        "source": "**",
        "headers": [
          {
            "key": "Cache-Control",
            "value": "public, max-age=31536000, immutable"
          }
        ]
      }
    ]
  }
}
```

## 12. Performance Targets (MVP)

### Critical Metrics

- First Contentful Paint (FCP): <1.5s
- Largest Contentful Paint (LCP): <2.5s
- Time to Interactive (TTI): <3.5s
- Cumulative Layout Shift (CLS): <0.1
- First Input Delay (FID): <100ms
- Autocomplete: <100ms (GPT-4.1 nano)
- Mode transitions: <50ms
- Dialog display: <100ms
- Inline diff: <200ms
- Key term spotting: <5s (GPT-4o-mini)

### Optimization Strategies

- Server Components for initial renders
- Streaming SSR for progressive loading
- Debounce autocomplete (150ms)
- Debounce diff calculation (500ms)
- Virtual scrolling for long lists
- Lazy load non-critical components
- Optimize Lighthouse score >90

## 13. Development Workflow

### Scripts

```json
{
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "test": "vitest",
    "test:ui": "vitest --ui",
    "test:e2e": "playwright test",
    "test:coverage": "vitest run --coverage",
    "test:contracts": "vitest run tests/api/**",
    "type-check": "tsc --noEmit",
    "validate": "npm run lint && npm run type-check && npm run test && npm run build"
  }
}
```

### Git Hooks (Pragmatic - Fast Feedback)

```bash
# .husky/pre-commit
npm run lint               # Enforce code style
npm run type-check         # Catch type errors

# Tests run in CI/CD pipeline, not pre-commit
# This keeps commits fast and doesn't block developer flow
```

### Development Flow

**Feature Development Process**:
```mermaid
1. Define data contracts (Zod schemas)
   ↓
2. Implement feature with TypeScript
   ↓
3. Manual testing in browser
   ↓
4. Write integration tests for critical paths
   ↓
5. Add E2E test if core user journey
   ↓
6. Commit (lint + type-check)
   ↓
7. CI/CD runs full test suite
```

**Branch Strategy** (MVP - Keep it Simple):
- `main` - Production-ready code
- `feature/*` - Feature branches
- No complex git-flow needed for MVP

**Code Quality Gates**:
1. **Pre-commit** (Local):
   - ESLint fixes auto-formatting
   - TypeScript compilation succeeds
   - Fast (<5 seconds)

2. **CI/CD** (GitHub Actions / Vercel):
   - All tests pass (integration + E2E)
   - Build succeeds
   - No blocking for non-critical failures in MVP phase

3. **Pre-deployment**:
   - Manual smoke test on staging
   - Key user journeys verified
   - Performance check (Lighthouse)

## 14. Dependencies Summary

### Core Dependencies

```json
{
  "dependencies": {
    "next": "15.1.0",
    "react": "19.1.1",
    "react-dom": "19.1.1",
    "typescript": "5.9.3",

    "@tiptap/react": "3.4.2",
    "@tiptap/starter-kit": "3.4.2",
    "@tiptap/extension-placeholder": "3.4.2",

    "firebase": "^10.x",
    "firebase-admin": "^12.x",

    "openai": "5.23.1",

    "dexie": "4.2.0",
    "dexie-react-hooks": "^1.1.0",

    "zustand": "5.0.8",
    "immer": "10.1.3",

    "zod": "3.25.67",
    "react-hook-form": "^7.x",
    "@hookform/resolvers": "^3.x",

    "tailwindcss": "4.1.13",
    "tailwind-merge": "^2.x",
    "class-variance-authority": "^0.7.x",
    "clsx": "^2.x",

    "lucide-react": "^0.460.x",
    "next-themes": "^0.3.x",
    "next-pwa": "5.6.0",

    "diff-match-patch": "^1.0.5",
    "date-fns": "^4.x"
  },
  "devDependencies": {
    "@types/node": "^22.x",
    "@types/react": "^19.x",
    "@types/react-dom": "^19.x",

    "vitest": "3.2.4",
    "@vitest/ui": "3.2.4",
    "@testing-library/react": "16.3.0",
    "@testing-library/jest-dom": "^6.x",
    "jsdom": "^25.x",

    "playwright": "1.55.0",
    "@playwright/test": "1.55.0",

    "eslint": "^9.x",
    "eslint-config-next": "15.1.0",
    "prettier": "^3.x",
    "prettier-plugin-tailwindcss": "^0.6.x",

    "fake-indexeddb": "^6.x"
  }
}
```

## 15. Migration from Tauri

### Removed Dependencies

- Tauri (no longer needed)
- @tauri-apps/\* packages

### Added Dependencies

- next-pwa for PWA support
- Replaced Tauri IPC with Next.js API routes
- Replaced Tauri file system with browser APIs

### Architecture Changes

- Desktop app → PWA (installable on all platforms)
- Tauri commands → Next.js API routes
- Local file system → IndexedDB (Dexie) + Firebase Storage

## 16. 4-Week Build Timeline (Revised for Next.js)

### Week 1: Foundation

- Next.js project setup with App Router
- Firebase integration (client + admin SDK)
- Shadcn UI components setup
- Basic authentication flow
- Mode switching logic + visual indicators
- Edit or Study Dialog

### Week 2: AI Autocomplete

- Tiptap editor integration
- AI autocomplete (GPT-4.1 nano via API route)
- Auto-save logic with version snapshots
- Freemium request tracking
- Local dictionary fallback

### Week 3: Diff & Key Terms

- Inline diff button + diff view (Edit Mode)
- AI Key Term Spotting (GPT-4o-mini via API route)
- Key terms sidebar UI
- Export key terms list

### Week 4: Polish & Launch Prep

- Note library + search
- 2-screen onboarding
- PWA configuration
- Performance optimization
- E2E testing
- Deployment to Vercel

This completes the revised technical specifications for the Next.js stack.
